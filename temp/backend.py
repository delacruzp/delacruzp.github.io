# -*- coding: utf-8 -*-
"""
               Temperature Extraction
===================================================

This module take as input a JSON file generated by the
BOX Station and use REGEX to extract the temperatures
predicted in this file. 

Finally it generates a tsv file (data.tsv) with
a daily aggregated prediction for the low and highs 
of each day.

If a file with the real temperatures for the forecasted
day is provided, its temperatures will be joined
and added to the data.tsv file.

"""

# Author: Caleb De La Cruz P. <cdelacru>

import sys
import re
import json
import pandas as pd
import numpy as np
from sklearn.feature_extraction.text import CountVectorizer
from datetime import datetime, timedelta
from time import time


def get_variation(variation_str):
    '''
    Given a adjective which variates the temperature it returns its numeric value
    within the [0-10] range.
    
    Ex.
        For the sentence: Temperature will be in the mid 20s
        variation_str = mid
        result = 5
        
        @variation_str: string
        @return int
    '''
    if variation_str == 'mid':
        return 5
    elif variation_str == 'upper':
        return 7
    elif variation_str == 'low' or variation_str == 'lower':
        return 0
    else:
        return 0

def is_duplicated(temperature, temperatures):
    '''
    Given a temperature dictionary and an array of temperatures 
    identifies if this particular temperature with this same unit
    exitst in the array
    
        @temperature: dict
        @temperatures: array of dicts
        @return: Boolean
    '''
    flag = False
    # Check if duplicated
    for temp in temperatures:
        if not temp['duplicated'] and             temp['temp_1']  == temperature['temp_1'] and             ((temp['is_range'] and temperature['is_range'] and temp['temp_2']== temperature['temp_2']) 
            or (not temp['is_range'] or not temperature['is_range'])) and \
            temp['unit']  == temperature['unit']:
                flag = True
                break;

    return flag


def csv(filename, df, columns=None): 
    '''
    Helper function to append datetime in which the files are generated to its name
    '''
    # Avoid replacing the generated files by adding the date in which they were generated
    filename = '%s %s.csv' % (datetime.now().strftime('%Y-%b-%d %I-%M-%S'), filename)

    # Generate File
    if columns:
        df.to_csv(filename, 
                          index=False, 
                          columns=columns)
    else:
        df.to_csv(filename, 
                          index=False)


# # Feature Extraction
def extract_temperatures(time, raw_text, field):
    '''
    Given a raw prediction text, it extracts the values which are considered 
    to be temperature using a set of regular expressions, which look for 
    temperature units such as: degrees, c, F, etc.
    
        @time: String with the date of the current forecast
        @raw_text: String with the current free text forecast
        @field: Field from which this info was obtained Ex. (near_term, short_term, long_term)
        @return: array of dictionaries with forecasted temperatures
    '''
    # Store all the temperatures extracted for this this date
    final_temperatures = []
    # Keep track of the number of temps prediction in the same date.
    multiple_temps = 0
    
    # Regular Expressions
    r_temperature_range = r'(?P<sentence>(?P<variation_1>(mid|upper|lower|low)\s*)?(?P<temp_1>[-]?[\s]?\d+[\s]?)(?P<unit_1>(degrees?|degs?|c|f|s)(?![\w/]))?(?P<divider>[\s]*(to|[-]|and)[\s]*)(?P<variation_2>(mid|upper|lower|low)\s*)?(?P<temp_2>[-]?[\s]?\d+[\s]?)(?P<unit_2>(degrees?|degs?|c|f|s)(?![\w/])))' 
    r_temperature_value = r'((?P<variation_1>(mid|upper|lower|low)\s*)?(?P<temp>[-]?[\s]?\d+[\s]?)(?P<unit>degrees?|degs?|c|f|s)(?![\w/]))'
    r_high_temp = r'(lows|low(er)? temp)'
    r_low_temp = r'(highs|high(er)? temp)'
    r_dewpoints = r'(dwpt|dewpoint|dew (point|pt))s?'
       
    
    # Split Into Sentences
    sentences = re.split(r'\.+', raw_text)
    
    # Clear Empty Sentences
    sentences = [x for x in sentences if len(x) > 2]
    
    # For each sentence
    for sentence in sentences:
        # Save a backup of the original sentence
        orig_sentence = sentence

        # Save all the temperatures in this sentence in this array
        temperatures = []
    
        # Extract Ranges of Values. Ex. Temps will be from 20s to 30s
        for obj in re.finditer(r_temperature_range, sentence, flags=re.IGNORECASE):
            temperature = {}
            temperature['var_1'] = obj.group('variation_1')
            temperature['temp_1'] = float(obj.group('temp_1').replace(' ',''))  + get_variation(temperature['var_1'])
            temperature['var_2'] = obj.group('variation_2')
            temperature['temp_2'] = float(obj.group('temp_2').replace(' ',''))  + get_variation(temperature['var_2'])
            temperature['unit'] = obj.group('unit_2').lower() 
            temperature['is_range'] = True

            if temperature['unit'] == 's':
                temperature['unit'] = 'f'

            temperature['duplicated'] = is_duplicated(temperature, temperatures)
            temperature['dewpoints'] = re.search(r_dewpoints, sentence, flags=re.IGNORECASE) is not None
            temperatures.append(temperature)
            
            # Check if for this same day there is more than one temperature being forecasted
            # we exclude dewpoings and celsisus because this temperature are specific for Air Temperature
            if not (temperature['duplicated'] or
                    temperature['dewpoints'] or
                    temperature['unit'] == 'c'
                   ):
                multiple_temps += 1


        # Remove Previously Extracted Ranges
        sentence = re.sub(r_temperature_range, '', sentence, flags=re.IGNORECASE)

        # Extract Individual Values. Ex. High temps will reach the 20 degrees.
        results = re.findall(r_temperature_value, sentence, flags=re.IGNORECASE)
        for result in results:
            temperature = {}
            temperature['var_1'] = result[2]
            temperature['temp_1'] = float(result[3].replace(' ','')) + get_variation(temperature['var_1'])
            temperature['unit'] = result[4].lower()
            temperature['is_range'] = False

            if temperature['unit'] == 's':
                temperature['unit'] = 'f'

            temperature['duplicated'] = is_duplicated(temperature, temperatures)
            temperature['dewpoints'] = re.search(r_dewpoints, sentence, flags=re.IGNORECASE) is not None
            temperatures.append(temperature)

            # Check if for this same day there is more than one temperature being forecasted
            # we exclude dewpoings and celsisus because this temperature are specific for Air Temperature
            if not (temperature['duplicated'] or
                    temperature['dewpoints'] or
                    temperature['unit'] == 'c'
                   ):
                multiple_temps += 1
        
        
        # Add properties which are the same for all the temperatures in the same sentence
        for temperature in temperatures:
            temperature['date'] = time
            temperature['sentence'] =  orig_sentence
            temperature['multiple_temps'] = multiple_temps
            temperature['field'] = field
            
            if re.search(r_low_temp, sentence, flags=re.IGNORECASE) is not None:
                temperature['boundary'] = 'lows'
            elif re.search(r_high_temp, sentence, flags=re.IGNORECASE) is not None:
                temperature['boundary'] = 'highs'
            else:
                temperature['boundary'] = None
                
            final_temperatures.append(temperature)

    return final_temperatures

def extract_word(data, fields, ngram, min_df):
    '''
    Given a dataframe and the columns you one to analyze. It will
    split the text in those columns into n-grams and count
    their frequency.
    
    Finally it generates a file with this text.
    
    '''
    
    vectorizer = CountVectorizer(stop_words='english', 
                                 ngram_range=ngram, 
                                 token_pattern=r'\b\w+\b', 
                                 min_df=min_df)
    
    bigResultDF = pd.DataFrame(columns=['date','word','frequency','term', 'size'])
    
    for field in fields:
        indexed = vectorizer.fit_transform(data[field])

        dictionary = np.array(vectorizer.get_feature_names())
        N = len(indexed.nonzero()[0])

        dates = df['fetch_time'][indexed.nonzero()[0]].astype(str).as_matrix()
        dates = dates.reshape(N,1)

        words = dictionary[indexed.nonzero()[1]]
        words = words.reshape(N,1)
        
        frequency = indexed[indexed.nonzero()]
        frequency = frequency.reshape(N,1)
        
        result = np.concatenate((dates, words, frequency), axis=1)
        
        resultDF = pd.DataFrame(result, columns=['date','word','frequency'])
        resultDF['term'] = field
        resultDF['size'] = resultDF['word'].apply(lambda x: len(x.split()))
        
        bigResultDF = bigResultDF.append(resultDF, ignore_index=True)
        
    # File Creation
    return bigResultDF


def generate_chart_data(df, filename='forecast.csv', real_temp_filename='real_temperatures.csv'):

    # Remove Celsius Degrees
    chart_df = df.loc[temperatures['unit'] != 'c']

    # Group by Date
    chart_df = chart_df.groupby([chart_df['date'].dt.date])
    chart_df = chart_df.agg({'temp_1' :  [np.min, np.max], 'temp_2' : [np.min, np.max]}) 

    # Get Boundaries
    min_column = chart_df.min(axis=1)
    max_column = chart_df.max(axis=1)
    
    # Concat and Rename Columns
    result = pd.concat([min_column, max_column], axis=1)\
              .reset_index()\
              .rename(index=str, columns={'date':'Date', 0: "Forecast Low", 1: "Forecast High"})
    
    real_temp_df = pd.read_csv(real_temp_filename)
    
    result['Date'] = pd.to_datetime(result.Date, format="%Y/%m/%d")
    real_temp_df['Date'] = pd.to_datetime(real_temp_df.Date, format="%Y/%m/%d")
    
    result = result.set_index('Date')
    real_temp_df = real_temp_df.set_index('Date')
    
    
    result = pd.merge(result, real_temp_df, how='inner', left_index=True, right_index=True)
    
    # Generate File
    result.to_csv(filename)
    
    return result




# --------------------------------
# -------- Implementation --------
# --------------------------------

if __name__ == "__main__":

    if len(sys.argv) > 1:
        filepath = sys.argv[1]
    else:
        filepath = 'box_station.json'

    # 1) Get Data
    print('1- Reading Data: %s' % filepath)
    df = pd.read_json(filepath)

    # 2) Extracting Temperatures
    print('2- Extracting Temperatures')
    features = []

    for idx, row in df.iterrows():
        # Extract Temperatures from the Near Term Field
        features += extract_temperatures(row['fetch_time'], row['near_term'], 'near')
        
    temperatures = pd.DataFrame(features)

    # 3) Generating Raw Data
    print('3- Generating Raw Data')
    csv('temperatures', temperatures, 
        columns=['date',           'field',  'dewpoints', 'duplicated', 'is_range', 
                 'multiple_temps', 'temp_1', 'temp_2',    'unit',
                 'boundary',       'var_1',  'var_2',     'sentence'])

    # 4) Generating Chart Data
    print('4- Generating Char Data')
    generate_chart_data(temperatures,
        filename='data.tsv', 
        real_temp_filename='real_temperatures.csv')

